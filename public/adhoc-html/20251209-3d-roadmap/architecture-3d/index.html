<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AWS Architecture Generator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a1c2e 0%, #0f1019 100%);
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            background: linear-gradient(to bottom, rgba(15,16,25,0.95) 0%, transparent 100%);
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title {
            color: white;
            font-size: 1.3rem;
            font-weight: 700;
        }
        
        .title span {
            color: #ff9900;
        }
        
        .arch-name {
            color: rgba(255,255,255,0.6);
            font-size: 0.85rem;
            margin-top: 4px;
        }
        
        .arch-name strong {
            color: #00c896;
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: #ff9900;
            color: #232f3e;
        }
        
        .btn-primary:hover {
            background: #ffb84d;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(15,16,25,0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 100;
            min-width: 300px;
            max-height: 450px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .info-title {
            color: #ff9900;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .resource-item:last-child {
            border-bottom: none;
        }
        
        .resource-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            flex-shrink: 0;
        }
        
        .resource-icon.vpc { background: rgba(124,77,255,0.2); }
        .resource-icon.subnet { background: rgba(0,200,150,0.2); }
        .resource-icon.ec2 { background: rgba(255,153,0,0.2); }
        .resource-icon.rds { background: rgba(52,152,219,0.2); }
        .resource-icon.alb { background: rgba(142,68,173,0.2); }
        .resource-icon.igw { background: rgba(46,204,113,0.2); }
        .resource-icon.user { background: rgba(52,152,219,0.2); }
        
        .resource-info {
            flex: 1;
            min-width: 0;
        }
        
        .resource-name {
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .resource-detail {
            color: rgba(255,255,255,0.5);
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .label-3d {
            background: rgba(15,16,25,0.9);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(5px);
        }
        
        .label-3d.vpc { background: rgba(124,77,255,0.9); border-color: rgba(124,77,255,0.5); }
        .label-3d.subnet { background: rgba(0,150,110,0.9); border-color: rgba(0,200,150,0.5); }
        .label-3d.ec2 { background: rgba(255,153,0,0.9); border-color: rgba(255,153,0,0.5); color: #232f3e; }
        .label-3d.alb { background: rgba(142,68,173,0.9); border-color: rgba(142,68,173,0.5); }
        .label-3d.igw { background: rgba(46,204,113,0.9); border-color: rgba(46,204,113,0.5); }
        .label-3d.user { background: rgba(52,152,219,0.9); border-color: rgba(52,152,219,0.5); }
        
        .label-3d .icon { margin-right: 6px; }
        .label-3d .detail {
            display: block;
            font-size: 9px;
            font-weight: 400;
            opacity: 0.8;
            font-family: 'JetBrains Mono', monospace;
            margin-top: 2px;
        }
        
        .hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.4);
            font-size: 0.75rem;
            z-index: 100;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1rem;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="loading" id="loading">Loading architecture...</div>

    <div class="header">
        <div>
            <div class="title"><span>AWS</span> Architecture 3D</div>
            <div class="arch-name" id="arch-name">Loading...</div>
        </div>
        <div class="controls">
            <button class="btn btn-secondary" id="btn-reset">üîÑ Reset View</button>
            <button class="btn btn-primary" id="btn-rotate">‚è∏Ô∏è Auto Rotate</button>
        </div>
    </div>

    <div class="info-panel">
        <div class="info-title">ARCHITECTURE COMPONENTS</div>
        <div id="resource-list"></div>
    </div>

    <div class="hint">„Éâ„É©„ÉÉ„Ç∞„ÅßÂõûËª¢ ‚Ä¢ „Çπ„ÇØ„É≠„Éº„É´„Åß„Ç∫„Éº„É†</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

    <script>
        // ============================================
        // Config
        // ============================================
        const AWS_COLORS = {
            vpc: 0x7c4dff,
            subnet: 0x00c896,
            'subnet-public': 0x00c896,
            'subnet-private': 0x3498db,
            ec2: 0xff9900,
            rds: 0x3498db,
            alb: 0x8e44ad,
            igw: 0x2ecc71,
            nat: 0xe74c3c,
            user: 0x3498db,
            background: 0x0f1019,
            grid: 0x2a2d3e,
            connection: 0x88ccff
        };

        const RESOURCE_ICONS = {
            vpc: 'üåê',
            subnet: 'üì¶',
            ec2: 'üíª',
            rds: 'üóÑÔ∏è',
            alb: '‚öñÔ∏è',
            igw: 'üåç',
            nat: 'üîÄ',
            user: 'üßë‚Äçüíª'
        };

        // AWSÂÖ¨Âºè„Ç¢„Ç§„Ç≥„É≥„Éë„Çπ
        const AWS_ICON_BASE = '../../AWS-icon';
        const AWS_ICONS = {
            ec2: `${AWS_ICON_BASE}/Architecture-Service-Icons_02072025/Arch_Compute/64/Arch_Amazon-EC2_64.png`,
            alb: `${AWS_ICON_BASE}/Resource-Icons_02072025/Res_Networking-Content-Delivery/Res_Elastic-Load-Balancing_Application-Load-Balancer_48.png`,
            igw: `${AWS_ICON_BASE}/Resource-Icons_02072025/Res_Networking-Content-Delivery/Res_Amazon-VPC_Internet-Gateway_48.png`
        };
        
        const AWS_ICON_COLORS = {
            ec2: 0xff9900,  // „Ç™„É¨„É≥„Ç∏
            alb: 0x8c4fff,  // Á¥´
            igw: 0x8c4fff   // Á¥´
        };

        // ============================================
        // Global Variables
        // ============================================
        let scene, camera, renderer, controls, labelRenderer;
        let autoRotate = true;
        let archData = null;
        let resourcePositions = {};
        let allResources = [];
        let vpcCenter = { x: 0, z: 0 };
        let vpcDimensions = { width: 0, height: 0, depth: 0 };
        let connectionLines = []; // Êé•Á∂öÁ∑öÔºà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®Ôºâ

        // ============================================
        // Main Init
        // ============================================
        async function init() {
            try {
                const response = await fetch('architecture.yaml');
                const yamlText = await response.text();
                archData = jsyaml.load(yamlText);
                console.log('Loaded architecture:', archData);
            } catch (error) {
                console.error('Failed to load YAML:', error);
                document.getElementById('loading').textContent = 'Error loading architecture.yaml';
                return;
            }

            setupScene();
            setupLighting();
            createGrid();
            generateArchitecture();
            
            if (archData.connections) {
                generateConnections();
            }

            updateUI();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('btn-reset').addEventListener('click', resetView);
            document.getElementById('btn-rotate').addEventListener('click', toggleRotate);

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        // ============================================
        // Scene Setup
        // ============================================
        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(AWS_COLORS.background);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(35, 30, 35);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.getElementById('canvas-container').appendChild(labelRenderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 100;
            controls.target.set(0, 6, 0);
            controls.autoRotate = autoRotate;
            controls.autoRotateSpeed = 0.5;
        }

        function setupLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(25, 40, 25);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0x7c4dff, 0.3);
            fillLight.position.set(-20, 15, -20);
            scene.add(fillLight);
        }

        function createGrid() {
            const gridHelper = new THREE.GridHelper(60, 60, AWS_COLORS.grid, AWS_COLORS.grid);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        // ============================================
        // Generate Architecture
        // ============================================
        function generateArchitecture() {
            if (!archData) return;

            // External resources (user, etc.)
            if (archData.external) {
                archData.external.forEach((res, idx) => {
                    if (res.user) {
                        createUser(res, -18, 10, 0);
                    }
                });
            }

            // VPC resources
            if (archData.resources) {
                archData.resources.forEach((resource, index) => {
                    if (resource.vpc) {
                        const vpcWidth = calculateVPCWidth(resource);
                        createVPC(resource, 0, vpcWidth);
                    }
                });
            }
        }

        function calculateVPCWidth(vpcResource) {
            const children = vpcResource.children || [];
            const subnetCount = children.filter(c => c.subnet).length;
            return Math.max(subnetCount * 10, 14);
        }

        // ============================================
        // Create User (Browser)
        // ============================================
        function createUser(resource, x, y, z) {
            const name = resource.user;
            const icon = resource.icon || 'üßë‚Äçüíª';
            
            const group = new THREE.Group();
            group.position.set(x, y, z);

            // Monitor
            const monitorGeometry = new THREE.BoxGeometry(3, 2, 0.2);
            const monitorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 80 });
            const monitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
            monitor.castShadow = true;
            group.add(monitor);

            // Screen
            const screenGeometry = new THREE.PlaneGeometry(2.6, 1.6);
            const screenMaterial = new THREE.MeshBasicMaterial({ color: 0x4488ff });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = 0.11;
            group.add(screen);

            // Stand
            const standGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
            const standMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.y = -1.5;
            group.add(stand);

            // Base
            const baseGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.15, 32);
            const base = new THREE.Mesh(baseGeometry, standMaterial);
            base.position.y = -2;
            group.add(base);

            scene.add(group);
            resourcePositions[name] = { x, y, z };
            allResources.push({ type: 'user', name, icon });
        }

        // ============================================
        // Create VPC
        // ============================================
        function createVPC(resource, startX, width) {
            const name = resource.vpc;
            const cidr = resource.cidr || '';
            const height = 14;
            const depth = 14;
            const centerX = startX;

            vpcCenter = { x: centerX, z: 0 };
            vpcDimensions = { width, height, depth };

            // VPC wireframe
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const edges = new THREE.EdgesGeometry(geometry);
            const edgeMaterial = new THREE.LineBasicMaterial({ color: AWS_COLORS.vpc, transparent: true, opacity: 0.8 });
            const wireframe = new THREE.LineSegments(edges, edgeMaterial);
            wireframe.position.set(centerX, height / 2, 0);
            scene.add(wireframe);

            // Transparent faces
            const faceMaterial = new THREE.MeshPhongMaterial({
                color: AWS_COLORS.vpc,
                transparent: true,
                opacity: 0.05,
                side: THREE.DoubleSide
            });
            const faceMesh = new THREE.Mesh(geometry, faceMaterial);
            faceMesh.position.set(centerX, height / 2, 0);
            scene.add(faceMesh);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(width - 0.5, depth - 0.5);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: AWS_COLORS.vpc, transparent: true, opacity: 0.15 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(centerX, 0.05, 0);
            floor.receiveShadow = true;
            scene.add(floor);

            resourcePositions[name] = { x: centerX, y: height / 2, z: 0 };
            allResources.push({ type: 'vpc', name, cidr });

            // Internet Gateway (on top of VPC)
            if (resource.igw) {
                createIGW(resource.igw, centerX, height, 0);
            }

            // Children
            if (resource.children) {
                const albs = resource.children.filter(c => c.alb);
                const subnets = resource.children.filter(c => c.subnet);

                // ALB (middle layer)
                albs.forEach((alb, idx) => {
                    createALB(alb, centerX, height - 3, 0);
                });

                // Subnets
                const subnetSpacing = 10;
                const startSubnetX = centerX - ((subnets.length - 1) * subnetSpacing) / 2;

                subnets.forEach((subnet, idx) => {
                    const subnetX = startSubnetX + idx * subnetSpacing;
                    createSubnet(subnet, subnetX, 0, 0);
                });
            }
        }

        // ============================================
        // Create Internet Gateway
        // ============================================
        function createIGW(name, x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y + 2, z);

            const size = 2.5;
            const color = AWS_ICON_COLORS.igw;

            // „ÉÜ„ÇØ„Çπ„ÉÅ„É£Ë™≠„ÅøËæº„Åø
            const textureLoader = new THREE.TextureLoader();
            const iconTexture = textureLoader.load(AWS_ICONS.igw);

            // 6Èù¢„ÅÆ„Éû„ÉÜ„É™„Ç¢„É´ÔºàÂâçÈù¢„ÅÆ„Åø„Ç¢„Ç§„Ç≥„É≥„ÄÅ‰ªñ„ÅØËâ≤Ôºâ
            const materials = [
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // right
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // left
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // top
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // bottom
                new THREE.MeshBasicMaterial({ map: iconTexture }),     // front („Ç¢„Ç§„Ç≥„É≥)
                new THREE.MeshPhongMaterial({ color, shininess: 80 })  // back
            ];

            const bodyGeometry = new THREE.BoxGeometry(size, size, size);
            const body = new THREE.Mesh(bodyGeometry, materials);
            body.castShadow = true;
            group.add(body);

            // Connection line down to VPC
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -size/2 - 0.1, 0),
                new THREE.Vector3(0, -size/2 - 1.5, 0)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: AWS_COLORS.igw, transparent: true, opacity: 0.6 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            group.add(line);

            scene.add(group);
            resourcePositions[name] = { x, y: y + 2, z };
            allResources.push({ type: 'igw', name });
        }

        // ============================================
        // Create ALB
        // ============================================
        function createALB(resource, x, y, z) {
            const name = resource.alb;
            const scheme = resource.scheme || 'internet-facing';

            const group = new THREE.Group();
            group.position.set(x, y, z);

            const size = 2.5;
            const color = AWS_ICON_COLORS.alb;

            // „ÉÜ„ÇØ„Çπ„ÉÅ„É£Ë™≠„ÅøËæº„Åø
            const textureLoader = new THREE.TextureLoader();
            const iconTexture = textureLoader.load(AWS_ICONS.alb);

            // 6Èù¢„ÅÆ„Éû„ÉÜ„É™„Ç¢„É´ÔºàÂâçÈù¢„ÅÆ„Åø„Ç¢„Ç§„Ç≥„É≥„ÄÅ‰ªñ„ÅØËâ≤Ôºâ
            const materials = [
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // right
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // left
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // top
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // bottom
                new THREE.MeshBasicMaterial({ map: iconTexture }),     // front („Ç¢„Ç§„Ç≥„É≥)
                new THREE.MeshPhongMaterial({ color, shininess: 80 })  // back
            ];

            const bodyGeometry = new THREE.BoxGeometry(size, size, size);
            const body = new THREE.Mesh(bodyGeometry, materials);
            body.castShadow = true;
            group.add(body);

            scene.add(group);
            resourcePositions[name] = { x, y, z };
            allResources.push({ type: 'alb', name, scheme });
        }

        // ============================================
        // Create Subnet
        // ============================================
        function createSubnet(resource, x, y, z) {
            const name = resource.subnet;
            const cidr = resource.cidr || '';
            const az = resource.az || '';
            const type = resource.type || 'public';
            
            const width = 8;
            const height = 8;
            const depth = 11;

            const group = new THREE.Group();
            group.position.set(x, y, z);

            const color = type === 'private' ? AWS_COLORS['subnet-private'] : AWS_COLORS.subnet;

            // Transparent faces (ÊúÄÂàù„Å´ÊèèÁîª„ÄÅÂ∏∏„Å´Ë°®Á§∫)
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const faceMaterial = new THREE.MeshBasicMaterial({ 
                color, 
                transparent: true, 
                opacity: 0.12, 
                side: THREE.DoubleSide,
                depthWrite: false,
                depthTest: true
            });
            const faceMesh = new THREE.Mesh(geometry, faceMaterial);
            faceMesh.position.y = height / 2;
            faceMesh.renderOrder = -1; // ‰ªñ„Çà„ÇäÂÖà„Å´ÊèèÁîª
            group.add(faceMesh);

            // Edges (Â∏∏„Å´Ë°®Á§∫„ÄÅVPC„Å®ÂêåÊßò„Å´ÊøÉ„ÅÑÁ∑ö)
            const edges = new THREE.EdgesGeometry(geometry);
            const edgeMaterial = new THREE.LineBasicMaterial({ 
                color, 
                transparent: false,
                linewidth: 2
            });
            const wireframe = new THREE.LineSegments(edges, edgeMaterial);
            wireframe.position.y = height / 2;
            wireframe.renderOrder = 1; // Èù¢„ÅÆÂæå„Å´ÊèèÁîª
            group.add(wireframe);

            // Floor („É©„Ç§„ÉÜ„Ç£„É≥„Ç∞ÂΩ±Èüø„Å™„Åó„ÄÅÂùá‰∏Ä„Å™Ëâ≤)
            const floorGeometry = new THREE.PlaneGeometry(width - 0.3, depth - 0.3);
            const floorMaterial = new THREE.MeshBasicMaterial({ 
                color, 
                transparent: true, 
                opacity: 0.25,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0.1;
            floor.renderOrder = -1;
            group.add(floor);

            scene.add(group);
            resourcePositions[name] = { x, y: height / 2, z };
            allResources.push({ type: 'subnet', name, cidr, az, subnetType: type });

            // Children (EC2, etc.)
            if (resource.children) {
                resource.children.forEach((child, idx) => {
                    if (child.ec2) {
                        createEC2(child, x, 2.5, z);
                    } else if (child.rds) {
                        createRDS(child, x, 2.5, z);
                    }
                });
            }
        }

        // ============================================
        // Create EC2
        // ============================================
        function createEC2(resource, x, y, z) {
            const name = resource.ec2;
            const instanceType = resource.type || 't3.micro';

            const group = new THREE.Group();
            group.position.set(x, y, z);

            const size = 2.5;
            const color = AWS_ICON_COLORS.ec2;

            // „ÉÜ„ÇØ„Çπ„ÉÅ„É£Ë™≠„ÅøËæº„Åø
            const textureLoader = new THREE.TextureLoader();
            const iconTexture = textureLoader.load(AWS_ICONS.ec2);

            // 6Èù¢„ÅÆ„Éû„ÉÜ„É™„Ç¢„É´ÔºàÂâçÈù¢„ÅÆ„Åø„Ç¢„Ç§„Ç≥„É≥„ÄÅ‰ªñ„ÅØËâ≤Ôºâ
            const materials = [
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // right
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // left
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // top
                new THREE.MeshPhongMaterial({ color, shininess: 80 }), // bottom
                new THREE.MeshBasicMaterial({ map: iconTexture }),     // front („Ç¢„Ç§„Ç≥„É≥)
                new THREE.MeshPhongMaterial({ color, shininess: 80 })  // back
            ];

            const bodyGeometry = new THREE.BoxGeometry(size, size, size);
            const body = new THREE.Mesh(bodyGeometry, materials);
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);

            scene.add(group);
            resourcePositions[name] = { x, y, z };
            allResources.push({ type: 'ec2', name, instanceType });
        }

        // ============================================
        // Create RDS
        // ============================================
        function createRDS(resource, x, y, z) {
            const name = resource.rds;
            const engine = resource.engine || 'mysql';

            const group = new THREE.Group();
            group.position.set(x, y, z);

            const geometry = new THREE.CylinderGeometry(1.2, 1.2, 2.5, 32);
            const material = new THREE.MeshPhongMaterial({ color: AWS_COLORS.rds, shininess: 80 });
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.castShadow = true;
            group.add(cylinder);

            // „É©„Éô„É´„ÅØÈùûË°®Á§∫Ôºà3DÁ©∫Èñì„Çí„Ç∑„É≥„Éó„É´„Å´Ôºâ

            scene.add(group);
            resourcePositions[name] = { x, y, z };
            allResources.push({ type: 'rds', name, engine });
        }

        // ============================================
        // Generate Connections
        // ============================================
        function generateConnections() {
            archData.connections.forEach(conn => {
                const fromPos = resourcePositions[conn.from];
                const toPos = resourcePositions[conn.to];

                if (fromPos && toPos) {
                    createConnection(fromPos, toPos, conn.label, conn.style);
                } else {
                    console.warn('Connection not found:', conn.from, '->', conn.to);
                }
            });
        }

        function createConnection(from, to, label, style) {
            // Create curved line
            const midY = Math.max(from.y, to.y) + 2;
            const midX = (from.x + to.x) / 2;
            const midZ = (from.z + to.z) / 2;

            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(from.x, from.y, from.z),
                new THREE.Vector3(midX, midY, midZ),
                new THREE.Vector3(to.x, to.y, to.z)
            );

            // „ÉÅ„É•„Éº„Éñ„Ç∏„Ç™„É°„Éà„É™ÔºàÂÖâ„Çã„ÉÅ„É•„Éº„ÉñÔºâ
            const tubeGeometry = new THREE.TubeGeometry(curve, 50, 0.1, 8, false);
            
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ddff,
                transparent: true,
                opacity: 0.7
            });

            const tube = new THREE.Mesh(tubeGeometry, material);
            scene.add(tube);
            
            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®„Å´‰øùÂ≠òÔºà‰ΩçÁõ∏„Çí„Åö„Çâ„Åó„Å¶Ëá™ÁÑ∂„Å´Ôºâ
            connectionLines.push({
                mesh: tube,
                material: material,
                phase: Math.random() * Math.PI * 2
            });
        }

        // ============================================
        // UI
        // ============================================
        function updateUI() {
            document.getElementById('arch-name').innerHTML = 
                `<strong>${archData.name}</strong> - ${archData.description}`;

            const listEl = document.getElementById('resource-list');
            listEl.innerHTML = '';

            allResources.forEach(res => {
                const item = document.createElement('div');
                item.className = 'resource-item';

                let detail = '';
                if (res.type === 'vpc') detail = res.cidr;
                else if (res.type === 'subnet') detail = `${res.cidr} ‚Ä¢ ${res.az}`;
                else if (res.type === 'ec2') detail = res.instanceType;
                else if (res.type === 'alb') detail = res.scheme;
                else if (res.type === 'user') detail = 'External';

                item.innerHTML = `
                    <div class="resource-icon ${res.type}">${RESOURCE_ICONS[res.type] || 'üì¶'}</div>
                    <div class="resource-info">
                        <div class="resource-name">${res.name}</div>
                        <div class="resource-detail">${detail}</div>
                    </div>
                `;
                listEl.appendChild(item);
            });
        }

        // ============================================
        // Controls
        // ============================================
        function resetView() {
            animateTo(camera.position, { x: 35, y: 30, z: 35 });
            animateTo(controls.target, { x: 0, y: 6, z: 0 });
        }

        function toggleRotate() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            document.getElementById('btn-rotate').textContent = autoRotate ? '‚è∏Ô∏è Auto Rotate' : '‚ñ∂Ô∏è Auto Rotate';
        }

        function animateTo(obj, target, duration = 1000) {
            const start = { x: obj.x, y: obj.y, z: obj.z };
            const startTime = performance.now();

            function update() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 3);

                obj.x = start.x + (target.x - start.x) * ease;
                obj.y = start.y + (target.y - start.y) * ease;
                obj.z = start.z + (target.z - start.z) * ease;

                if (progress < 1) requestAnimationFrame(update);
            }
            update();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.003; // ÁÇπÊªÖÈÄüÂ∫¶
            
            // „ÉÅ„É•„Éº„Éñ„ÅÆÁÇπÊªÖ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
            connectionLines.forEach(conn => {
                if (conn.material) {
                    // „Çµ„Ç§„É≥Ê≥¢„ÅßÁÇπÊªÖÔºà0.3„Äú1.0Ôºâ
                    const pulse = Math.sin(time + conn.phase) * 0.35 + 0.65;
                    conn.material.opacity = pulse;
                }
            });
            
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
